(use-modules (minikanren language)
             (minikanren examples lists)
             (minikanren dcg))

(define (lexo in cat sem)
  (fresh (x y c)
    (membero (list in cat sem)
             `((bertrand  np       bertrand)
               (terry     np       terry)
               (marcel    np       marcel)
               (principia np       principia)
               (completeness np    completeness)
               (halts     (\ s np) (lambda (,x)
                                     (halts ,x)))
               (wrote     (/ (\ s np) np)
                          (lambda (,x)
                            (lambda (,y)
                              (wrote ,y ,x))))
               (met       (/ (\ s np) np)
                          (lambda (,x)
                            (lambda (,y)
                              (met ,y ,x))))
               (conjectured (/ (\ s np) np)
                            (lambda (,x)
                              (lambda (,y)
                                (conjectured ,y ,x))))
               (proved (/ (\ s np) np)
                       (lambda (,x)
                         (lambda (,y)
                           (proved ,y ,x))))
               (and       (/ (\ ,c ,c) ,c)
                          (lambda (,x)
                            (lambda (,y)
                              (and ,y ,x))))))))

(define (combine a b r)
  (conde ((== a `(/ ,r ,b)))
         ((== b `(\ ,r ,a)))))

(define (combine-sem a sa b sb r sr)
  (fresh (sr-l sr-r)
    (conde
     ;; basic
     ((== a `(/ ,r ,b))
      (== sa `(lambda (,sb) ,sr)))
     ((== b `(\ ,r ,a))
      (== sb `(lambda (,sa) ,sr)))
     ;; and
     ((== a `(/ ,r ,b))
      (== sa `(and (lambda (,sb) ,sr-l)
                   (lambda (,sb) ,sr-r)))
      (== sr `(and ,sr-l ,sr-r)))
     ((== b `(\ ,r ,a))
      (== sb `(and (lambda (,sa) ,sr-l)
                   (lambda (,sa) ,sr-r)))
      (== sr `(and ,sr-l ,sr-r))))))

(--> (lex in ty sem)
  (conde (`(,in) (escape (lexo in ty sem)))))

(--> (parse ty tree sem)
  (fresh (tok a b l r ls rs)
    (conde ((== tree `(,tok : ,ty))
            (lex tok ty sem))
           ((escape (combine a b ty))
            (== tree `(,l ,r : ,ty))
            (parse a l ls)
            (parse b r rs)
            (escape (combine-sem a ls b rs ty sem))))))

(define (test q)
  (fresh (text tree sem)
    (== q (list text tree sem))
    (parse 's tree sem text '())
    (membero 'and text)))

;; browse through results
;; (runi test)
;; (((bertrand wrote bertrand and bertrand) ((bertrand : np) ((wrote : (/ (\ s np) np)) ((bertrand : np) ((and : (/ (\ np np) np)) (bertrand : np) : (\ np np)) : np) : (\ s np)) : s) (wrote bertrand (and bertrand bertrand))) where)
;; (another? y/n)
;; (((bertrand wrote bertrand and terry) ((bertrand : np) ((wrote : (/ (\ s np) np)) ((bertrand : np) ((and : (/ (\ np np) np)) (terry : np) : (\ np np)) : np) : (\ s np)) : s) (wrote bertrand (and bertrand terry))) where)
;; (another? y/n)
;; (((bertrand wrote bertrand and marcel) ((bertrand : np) ((wrote : (/ (\ s np) np)) ((bertrand : np) ((and : (/ (\ np np) np)) (marcel : np) : (\ np np)) : np) : (\ s np)) : s) (wrote bertrand (and bertrand marcel))) where)
;; (another? y/n)
;; (((bertrand wrote bertrand and principia) ((bertrand : np) ((wrote : (/ (\ s np) np)) ((bertrand : np) ((and : (/ (\ np np) np)) (principia : np) : (\ np np)) : np) : (\ s np)) : s) (wrote bertrand (and bertrand principia))) where)
;; (another? y/n)
;; (((bertrand wrote bertrand and completeness) ((bertrand : np) ((wrote : (/ (\ s np) np)) ((bertrand : np) ((and : (/ (\ np np) np)) (completeness : np) : (\ np np)) : np) : (\ s np)) : s) (wrote bertrand (and bertrand completeness))) where)
;; (another? y/n)
;; (((bertrand wrote terry and bertrand) ((bertrand : np) ((wrote : (/ (\ s np) np)) ((terry : np) ((and : (/ (\ np np) np)) (bertrand : np) : (\ np np)) : np) : (\ s np)) : s) (wrote bertrand (and terry bertrand))) where)
;; (another? y/n)
;; (((bertrand met bertrand and bertrand) ((bertrand : np) ((met : (/ (\ s np) np)) ((bertrand : np) ((and : (/ (\ np np) np)) (bertrand : np) : (\ np np)) : np) : (\ s np)) : s) (met bertrand (and bertrand bertrand))) where)
;; (another? y/n)
;; (((terry wrote bertrand and bertrand) ((terry : np) ((wrote : (/ (\ s np) np)) ((bertrand : np) ((and : (/ (\ np np) np)) (bertrand : np) : (\ np np)) : np) : (\ s np)) : s) (wrote terry (and bertrand bertrand))) where)

(define (test-text t q)
  (fresh (tree)
    (parse 's tree q t '())))

;; scheme@(guile-user)> (run^ 1 (lambda (q) (test-text '(marcel conjectured and proved completeness) q)))
;; $2 = (((and (proved marcel completeness) (conjectured marcel completeness)) where))
